{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"1-demo.rzk/","text":"Demo \u00b6 Disclaimers \u00b6 Info This demo is for the \u00abInteractions of Proof Assistants and Mathematics\u00bb school in Regensburg, September 18\u201329, 2023 and contains introduction to the syntax of Rzk and basics of theorem proving in Rzk, as well as a few exercises and links to formalisation projects. Warning This demo relies on rzk version 0.5.4 and might not be up-to-date, as the proof assistant is in active development and breaking changes should be expected with further releases. Setup \u00b6 To check the formalisations in this demo you can: Have rzk installed locally (the recommended way is to have VS Code extension for Rzk to handle it for you). and running rzk typecheck src/*.rzk.md from the root of this project. Use an online playground at https://rzk-lang.github.io/rzk/v0.5.4/playground/ (and copy-paste code blocks there one by one) Formalisation project structure \u00b6 Usually, formalisation projects in Rzk consist of multiple Rzk (or literate Rzk) files. For example, this demo project has the following structure: itp-school-2023-demo \u2502 ... \u2514\u2500\u2500 src \u251c\u2500\u2500 1-demo.rzk.md \u2514\u2500\u2500 2-exercises.rzk.md The formalisations are located in the src/ directory and contain just the two literate Rzk Markdown files. For another example, rzk-lang/sHoTT has its formalisations further split into subdirectories: sHoTT \u2502 ... \u2514\u2500\u2500 src \u251c\u2500\u2500 STYLEGUIDE.md \u251c\u2500\u2500 hott \u2502 \u251c\u2500\u2500 00-common.rzk.md \u2502 \u251c\u2500\u2500 01-paths.rzk.md \u2502 \u251c\u2500\u2500 02-homotopies.rzk.md \u2502 \u251c\u2500\u2500 03-equivalences.rzk.md \u2502 \u251c\u2500\u2500 04-half-adjoint-equivalences.rzk.md \u2502 \u251c\u2500\u2500 05-sigma.rzk.md \u2502 \u251c\u2500\u2500 06-contractible.rzk.md \u2502 \u251c\u2500\u2500 07-fibers.rzk.md \u2502 \u251c\u2500\u2500 08-families-of-maps.rzk.md \u2502 \u251c\u2500\u2500 09-propositions.rzk.md \u2502 \u2514\u2500\u2500 10-trivial-fibrations.rzk.md \u251c\u2500\u2500 index.md \u2514\u2500\u2500 simplicial-hott \u251c\u2500\u2500 03-simplicial-type-theory.rzk.md \u251c\u2500\u2500 04-extension-types.rzk.md \u251c\u2500\u2500 05-segal-types.rzk.md \u251c\u2500\u2500 06-2cat-of-segal-types.rzk.md \u251c\u2500\u2500 07-discrete.rzk.md \u251c\u2500\u2500 08-covariant.rzk.md \u251c\u2500\u2500 09-yoneda.rzk.md \u251c\u2500\u2500 10-rezk-types.rzk.md \u2514\u2500\u2500 12-cocartesian.rzk.md Running Rzk \u00b6 To typecheck files, at the moment you have to run the following command in the terminal: rzk typecheck FILE-1 FILE-2 ... FILE-N Warning It is important to pass formalisation files in the order you want them to be checked, as dependencies between files (in the form of imports) are not implemented yet. Tip Starting filenames with numbers (as in the examples above) helps automatically achieve the desired order when using wildcars (e.g. rzk typecheck src/*.rzk.md ), although in a slightly inelegant way. Literate Rzk \u00b6 If you are familiar with Markdown, then the recommended approach is to use literate Rzk Markdown, so that conventional Markdown rendering tools can be used to produce readable documentation from the formalisation files. For instance, this file is a literate Rzk Markdown file! Syntax overview \u00b6 Each file in Rzk (or literate Rzk) must start with a declaration of the version/dialect used. We will use (the only supported) rzk-1 dialect: #lang rzk-1 The rest of the file contains primarily of #define -statements, each of which introduces a new definition into scope. For example, consider the following definition: #define modus-ponens ( A B : U) : (A \u2192 B) \u2192 A \u2192 B := \\ f x \u2192 f x Going line by line, we have modus-ponens as the name of a new definition two parameters \u2014 A and B (both of type U , meaning A and B are types 1 ) declared type of modus-ponens is (A \u2192 B) \u2192 A \u2192 B declared term (value) of modus-ponens is \\ f x \u2192 f x Rzk typechecks the term against the declared type and, if no type errors found, remembers this definition for future use. Unicode \u00b6 Rzk supports both ASCII and Unicode versions of many syntactic constructions. We will use the following Unicode symbols: -> should be always replaced with \u2192 ( \\to ) |-> should be always replaced with \u21a6 ( \\mapsto ) === should be always replaced with \u2261 ( \\equiv ) <= should be always replaced with \u2264 ( \\<= ) /\\ should be always replaced with \u2227 ( \\and ) \\/ should be always replaced with \u2228 ( \\or ) 0_2 should be always replaced with 0\u2082 ( 0\\2 ) 1_2 should be always replaced with 1\u2082 ( 1\\2 ) I * J should be always replaced with I \u00d7 J ( \\x or \\times ) We use ASCII versions for TOP and BOT since \u22a4 and \u22a5 do not read better in the code. Variables \u00b6 We will use the following identifiers without corresponding term definitions. These will serve as assumptions to be used for demonstration purposes: #variables X : U #variables y z : X Dependent types with Rzk \u00b6 We now proceed to look at the primitives in Rzk for working with dependent types. Functions \u00b6 The type ( x : A) \u2192 B x is the type of (dependent) functions with an argument of type A and, for each input x , the output type B x . As a simple example of a dependent function, consider the identity function: #define identity : ( A : U) \u2192 ( x : A) \u2192 A := \\ A x \u2192 x Since we are not using x in the type of identity , we can simply write the type of the argument, without providing its name: #define identity\u2081 : ( A : U) \u2192 A \u2192 A := \\ A x \u2192 x We can write this definition differently, by putting ( A : U) into parameters (before : ), and omitting it in the lambda abstraction: #define identity\u2082 ( A : U) : A \u2192 A := \\ x \u2192 x We could also move x into parameters as well, although this probably does not increase readability anymore: #define identity\u2083 ( A : U) ( x : A) : A := x We can compute the identity using #compute command: #compute identity You should see the following after running Rzk: [ 8 out of 13 ] Computing WHNF for identity \\ (A : U) \u2192 \\ (x : A) \u2192 x We can also apply identity to the variables we have introduced earlier: #compute identity X -- \\ (x : X) \u2192 x #compute identity X z -- z Identity type \u00b6 For each type ( A : U) and elements ( a b : A) we have the identity type a =_{A} b of equalities (identities, paths) between a and b . #define FunExt : U := ( A : U) \u2192 ( B : U) \u2192 ( f : A \u2192 B) \u2192 ( g : A \u2192 B) \u2192 ( (x : A) \u2192 f x =_{B} g x) \u2192 (f =_{A \u2192 B} g) Rzk can figure out the type indices for identity types and we can omit them: #define FunExt\u2081 : U := ( A : U) \u2192 ( B : U) \u2192 ( f : A \u2192 B) \u2192 ( g : A \u2192 B) \u2192 ( (x : A) \u2192 f x = g x) \u2192 (f = g) One way to prove an equality that exists for all types, is the proof by reflexivity. For example, #define identity-x-eq-x ( A : U) ( x : A) : (identity A x = x) := refl _{x : A} Indeed, identity A x computes to x , and is therefore definitionally (computatioally) equal to it allowing for the use of refl_{x : A} . Again, Rzk can figure out indices accepting refl_{x} or just refl . Using a value of an identity type requires the path induction, which we can define via the built-in version of it, idJ : #define ind-path ( A : U) ( a : A) ( C : ( x : A) -> (a = x) -> U) ( d : C a refl ) ( b : A) : ( p : a = b) \u2192 C b p := \\ p \u2192 idJ (A, a, C, d, b, p) As an example, we can show symmetry for equality types by induction on the argument of type a = b : #define inverse ( A : U) ( a b : A) : (a = b) \u2192 (b = a) := ind-path A a ( \\ x _ \u2192 x = a) refl b Dependent sums \u00b6 The type \u03a3 ( x : A), B x is a type of (dependent) pairs where the first component (named x here) is of type A , and the second component is of type B x . For example, preimages (fibers) of functions can be defined using \u03a3 -types: #define preimage ( A B : U) ( f : A \u2192 B) ( y : B) : U := \u03a3 ( x : A), (f x = y) An element of a type \u03a3 (x : A), B x is given by a pair of elements (a, b) of types A and B a correspondingly. For example, we can provide an element in the preimage of identity X at z : X : #define preimage-of-identity-X-at-z : preimage X X (identity X) z := (z, refl ) HoTT with Rzk \u00b6 In HoTT (and in Rzk), the identity type is not always a proposition and refl might not be the only proof of equality! Type Error! #define does-not-typecheck ( A : U) ( x : A) ( p : x = x) : p = refl := refl -- path induction on p also cannot work! Info At the moment Rzk does not have support for higher inductive types, but it is expected in the future. Simplicial types with Rzk \u00b6 Following Riehl\u2013Shulman's paper 2 , Rzk has cube and tope layers 3 . These provide the ability to specify (higher) diagram schemas. For the purposes of his demo, we will only care about the directed interval cube 2 , 2-dimensional directed cube ( 2 \u00d7 2 ) , and 3-dimensional directed cube ( 2 \u00d7 2 \u00d7 2 ) . A cube may have points in it, and the directed interval 2 has two known points 0\u2082 : 2 and 1\u2082 : 2 . Tope layer adds logical constraints on the points in a cube, \"carving out\" a shape inside a space. There is a handful of ways to specify topes: TOP selects all points (provides no constraints) BOT selects no points (producing an empty shape) (\u03c6 \u2227 \u03c8) selects all points that satisfy both \u03c6 and \u03c8 (\u03c6 \u2228 \u03c8) selects all points that satisfy \u03c6 or \u03c8 (or both) (t \u2261 s) selects all points such that t is equal to s (t \u2264 s) selects all points such that t \u2264 s (only when both t and s are in 2 ) Mostly for technical reasons, we define shapes as mappings from cubes into the TOPE universe. For example, here is a shape that carves a (directed) triangle out of a (directed) square: #define \u0394\u00b2 : ( 2 \u00d7 2 ) \u2192 TOPE := \\ (t, s) \u2192 (s \u2264 t) Another example would be the horn shape that only takes two edges of a square: #define \u039b : ( 2 \u00d7 2 ) \u2192 TOPE := \\ (t, s) \u2192 (s \u2261 0\u2082 ) \u2228 (t \u2261 1\u2082 ) We could refine this definition by specifying that it is a subshape of \u0394\u00b2 : #define \u039b' : ( (t, s) : 2 \u00d7 2 | \u0394\u00b2 (t, s) ) \u2192 TOPE := \\ (t, s) \u2192 (s \u2261 0\u2082 ) \u2228 (t \u2261 1\u2082 ) Since shapes have the information about the cube in their types, Rzk provides an implicit coercion, allowing shorter definitions: #define \u039b'' : \u0394\u00b2 \u2192 TOPE := \\ (t, s) \u2192 (s \u2261 0\u2082 ) \u2228 (t \u2261 1\u2082 ) Note This more precise type expresses a restriction on the definition of \u039b'' , but, perhaps counterintuitively, not on the input points! With this type, Rzk additionally checks that (s \u2261 0) \u2228 (t \u2261 1 ) implies \u0394\u00b2 (t, s) for all t , s . However, we can still apply \u039b'' to all points in the cube ( 2 \u00d7 2 ) . Mapping from a shape into a type, effectively selects a concrete diagram in it. We can select a subdiagram, simply by restricting to a subshape: #define horn-restriction ( A : U) : (\u0394\u00b2 \u2192 A) \u2192 (\u039b \u2192 A) := \\ f t \u2192 f t To construct diagrams from parts, we can use recOR by specifying values for several shapes. Rzk will be checking that provided values agree (definitionally) on the intersections of these shapes. For example, given a triangle, we can construct a square: #define unfolding-square ( A : U) ( triangle : \u0394\u00b2 \u2192 A) : ( 2 \u00d7 2 ) \u2192 A := \\ (t, s) \u2192 recOR ( t \u2264 s \u21a6 triangle (s , t) , s \u2264 t \u21a6 triangle (t , s)) Extension types with Rzk \u00b6 Mapping from a shape into a type, we get a diagram. To fix some parts of the diagram, we can specify refinements \u2014 for each subshape we want to fix, we provide an explicit term of the proper type. For example, taking a diagram in A correspoding to the directed interval 2 and fixing the endpoints, we get the type of all arrows between two given points in A : #define hom ( A : U) ( x y : A) : U := ( t : 2 ) \u2192 A [ t \u2261 0\u2082 \u21a6 x , t \u2261 1\u2082 \u21a6 y ] We can show that the diagram 2 \u2192 A consists exactly of two elements and an arrow between them: #define \u03a3-arrow ( A : U) : U := \u03a3 ( x : A), \u03a3 ( y : A), hom A x y #define 2-to-\u03a3 ( A : U) : ( 2 \u2192 A) \u2192 \u03a3-arrow A := \\ d \u2192 (d 0\u2082 , (d 1\u2082 , d)) #define \u03a3-to-2 ( A : U) : (\u03a3-arrow A) \u2192 ( 2 \u2192 A) := \\ (x, (y, f)) \u2192 \\ t \u2192 recOR ( t \u2261 0\u2082 \u21a6 x , t \u2261 1\u2082 \u21a6 y , TOP \u21a6 f t ) Technical cleanup \u00b6 The following definitions silence errors about unused variables. #define unused-y : X := y #define unused-z : X := z @import url(https://fonts.googleapis.com/css2?family=Noto+Serif&amp;display=swap); text, textPath { font-family: Noto Serif; font-size: 28px; dominant-baseline: middle; text-anchor: middle; } technically, in Rzk currently U contains also CUBE , TOPE universes, and itself! \u21a9 Emily Riehl & Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 \u21a9 Instead of builtin layers, Rzk uses CUBE and TOPE universes to separate them from the types. \u21a9","title":"Demo"},{"location":"1-demo.rzk/#demo","text":"","title":"Demo"},{"location":"1-demo.rzk/#disclaimers","text":"Info This demo is for the \u00abInteractions of Proof Assistants and Mathematics\u00bb school in Regensburg, September 18\u201329, 2023 and contains introduction to the syntax of Rzk and basics of theorem proving in Rzk, as well as a few exercises and links to formalisation projects. Warning This demo relies on rzk version 0.5.4 and might not be up-to-date, as the proof assistant is in active development and breaking changes should be expected with further releases.","title":"Disclaimers"},{"location":"1-demo.rzk/#setup","text":"To check the formalisations in this demo you can: Have rzk installed locally (the recommended way is to have VS Code extension for Rzk to handle it for you). and running rzk typecheck src/*.rzk.md from the root of this project. Use an online playground at https://rzk-lang.github.io/rzk/v0.5.4/playground/ (and copy-paste code blocks there one by one)","title":"Setup"},{"location":"1-demo.rzk/#formalisation-project-structure","text":"Usually, formalisation projects in Rzk consist of multiple Rzk (or literate Rzk) files. For example, this demo project has the following structure: itp-school-2023-demo \u2502 ... \u2514\u2500\u2500 src \u251c\u2500\u2500 1-demo.rzk.md \u2514\u2500\u2500 2-exercises.rzk.md The formalisations are located in the src/ directory and contain just the two literate Rzk Markdown files. For another example, rzk-lang/sHoTT has its formalisations further split into subdirectories: sHoTT \u2502 ... \u2514\u2500\u2500 src \u251c\u2500\u2500 STYLEGUIDE.md \u251c\u2500\u2500 hott \u2502 \u251c\u2500\u2500 00-common.rzk.md \u2502 \u251c\u2500\u2500 01-paths.rzk.md \u2502 \u251c\u2500\u2500 02-homotopies.rzk.md \u2502 \u251c\u2500\u2500 03-equivalences.rzk.md \u2502 \u251c\u2500\u2500 04-half-adjoint-equivalences.rzk.md \u2502 \u251c\u2500\u2500 05-sigma.rzk.md \u2502 \u251c\u2500\u2500 06-contractible.rzk.md \u2502 \u251c\u2500\u2500 07-fibers.rzk.md \u2502 \u251c\u2500\u2500 08-families-of-maps.rzk.md \u2502 \u251c\u2500\u2500 09-propositions.rzk.md \u2502 \u2514\u2500\u2500 10-trivial-fibrations.rzk.md \u251c\u2500\u2500 index.md \u2514\u2500\u2500 simplicial-hott \u251c\u2500\u2500 03-simplicial-type-theory.rzk.md \u251c\u2500\u2500 04-extension-types.rzk.md \u251c\u2500\u2500 05-segal-types.rzk.md \u251c\u2500\u2500 06-2cat-of-segal-types.rzk.md \u251c\u2500\u2500 07-discrete.rzk.md \u251c\u2500\u2500 08-covariant.rzk.md \u251c\u2500\u2500 09-yoneda.rzk.md \u251c\u2500\u2500 10-rezk-types.rzk.md \u2514\u2500\u2500 12-cocartesian.rzk.md","title":"Formalisation project structure"},{"location":"1-demo.rzk/#running-rzk","text":"To typecheck files, at the moment you have to run the following command in the terminal: rzk typecheck FILE-1 FILE-2 ... FILE-N Warning It is important to pass formalisation files in the order you want them to be checked, as dependencies between files (in the form of imports) are not implemented yet. Tip Starting filenames with numbers (as in the examples above) helps automatically achieve the desired order when using wildcars (e.g. rzk typecheck src/*.rzk.md ), although in a slightly inelegant way.","title":"Running Rzk"},{"location":"1-demo.rzk/#literate-rzk","text":"If you are familiar with Markdown, then the recommended approach is to use literate Rzk Markdown, so that conventional Markdown rendering tools can be used to produce readable documentation from the formalisation files. For instance, this file is a literate Rzk Markdown file!","title":"Literate Rzk"},{"location":"1-demo.rzk/#syntax-overview","text":"Each file in Rzk (or literate Rzk) must start with a declaration of the version/dialect used. We will use (the only supported) rzk-1 dialect: #lang rzk-1 The rest of the file contains primarily of #define -statements, each of which introduces a new definition into scope. For example, consider the following definition: #define modus-ponens ( A B : U) : (A \u2192 B) \u2192 A \u2192 B := \\ f x \u2192 f x Going line by line, we have modus-ponens as the name of a new definition two parameters \u2014 A and B (both of type U , meaning A and B are types 1 ) declared type of modus-ponens is (A \u2192 B) \u2192 A \u2192 B declared term (value) of modus-ponens is \\ f x \u2192 f x Rzk typechecks the term against the declared type and, if no type errors found, remembers this definition for future use.","title":"Syntax overview"},{"location":"1-demo.rzk/#unicode","text":"Rzk supports both ASCII and Unicode versions of many syntactic constructions. We will use the following Unicode symbols: -> should be always replaced with \u2192 ( \\to ) |-> should be always replaced with \u21a6 ( \\mapsto ) === should be always replaced with \u2261 ( \\equiv ) <= should be always replaced with \u2264 ( \\<= ) /\\ should be always replaced with \u2227 ( \\and ) \\/ should be always replaced with \u2228 ( \\or ) 0_2 should be always replaced with 0\u2082 ( 0\\2 ) 1_2 should be always replaced with 1\u2082 ( 1\\2 ) I * J should be always replaced with I \u00d7 J ( \\x or \\times ) We use ASCII versions for TOP and BOT since \u22a4 and \u22a5 do not read better in the code.","title":"Unicode"},{"location":"1-demo.rzk/#variables","text":"We will use the following identifiers without corresponding term definitions. These will serve as assumptions to be used for demonstration purposes: #variables X : U #variables y z : X","title":"Variables"},{"location":"1-demo.rzk/#dependent-types-with-rzk","text":"We now proceed to look at the primitives in Rzk for working with dependent types.","title":"Dependent types with Rzk"},{"location":"1-demo.rzk/#functions","text":"The type ( x : A) \u2192 B x is the type of (dependent) functions with an argument of type A and, for each input x , the output type B x . As a simple example of a dependent function, consider the identity function: #define identity : ( A : U) \u2192 ( x : A) \u2192 A := \\ A x \u2192 x Since we are not using x in the type of identity , we can simply write the type of the argument, without providing its name: #define identity\u2081 : ( A : U) \u2192 A \u2192 A := \\ A x \u2192 x We can write this definition differently, by putting ( A : U) into parameters (before : ), and omitting it in the lambda abstraction: #define identity\u2082 ( A : U) : A \u2192 A := \\ x \u2192 x We could also move x into parameters as well, although this probably does not increase readability anymore: #define identity\u2083 ( A : U) ( x : A) : A := x We can compute the identity using #compute command: #compute identity You should see the following after running Rzk: [ 8 out of 13 ] Computing WHNF for identity \\ (A : U) \u2192 \\ (x : A) \u2192 x We can also apply identity to the variables we have introduced earlier: #compute identity X -- \\ (x : X) \u2192 x #compute identity X z -- z","title":"Functions"},{"location":"1-demo.rzk/#identity-type","text":"For each type ( A : U) and elements ( a b : A) we have the identity type a =_{A} b of equalities (identities, paths) between a and b . #define FunExt : U := ( A : U) \u2192 ( B : U) \u2192 ( f : A \u2192 B) \u2192 ( g : A \u2192 B) \u2192 ( (x : A) \u2192 f x =_{B} g x) \u2192 (f =_{A \u2192 B} g) Rzk can figure out the type indices for identity types and we can omit them: #define FunExt\u2081 : U := ( A : U) \u2192 ( B : U) \u2192 ( f : A \u2192 B) \u2192 ( g : A \u2192 B) \u2192 ( (x : A) \u2192 f x = g x) \u2192 (f = g) One way to prove an equality that exists for all types, is the proof by reflexivity. For example, #define identity-x-eq-x ( A : U) ( x : A) : (identity A x = x) := refl _{x : A} Indeed, identity A x computes to x , and is therefore definitionally (computatioally) equal to it allowing for the use of refl_{x : A} . Again, Rzk can figure out indices accepting refl_{x} or just refl . Using a value of an identity type requires the path induction, which we can define via the built-in version of it, idJ : #define ind-path ( A : U) ( a : A) ( C : ( x : A) -> (a = x) -> U) ( d : C a refl ) ( b : A) : ( p : a = b) \u2192 C b p := \\ p \u2192 idJ (A, a, C, d, b, p) As an example, we can show symmetry for equality types by induction on the argument of type a = b : #define inverse ( A : U) ( a b : A) : (a = b) \u2192 (b = a) := ind-path A a ( \\ x _ \u2192 x = a) refl b","title":"Identity type"},{"location":"1-demo.rzk/#dependent-sums","text":"The type \u03a3 ( x : A), B x is a type of (dependent) pairs where the first component (named x here) is of type A , and the second component is of type B x . For example, preimages (fibers) of functions can be defined using \u03a3 -types: #define preimage ( A B : U) ( f : A \u2192 B) ( y : B) : U := \u03a3 ( x : A), (f x = y) An element of a type \u03a3 (x : A), B x is given by a pair of elements (a, b) of types A and B a correspondingly. For example, we can provide an element in the preimage of identity X at z : X : #define preimage-of-identity-X-at-z : preimage X X (identity X) z := (z, refl )","title":"Dependent sums"},{"location":"1-demo.rzk/#hott-with-rzk","text":"In HoTT (and in Rzk), the identity type is not always a proposition and refl might not be the only proof of equality! Type Error! #define does-not-typecheck ( A : U) ( x : A) ( p : x = x) : p = refl := refl -- path induction on p also cannot work! Info At the moment Rzk does not have support for higher inductive types, but it is expected in the future.","title":"HoTT with Rzk"},{"location":"1-demo.rzk/#simplicial-types-with-rzk","text":"Following Riehl\u2013Shulman's paper 2 , Rzk has cube and tope layers 3 . These provide the ability to specify (higher) diagram schemas. For the purposes of his demo, we will only care about the directed interval cube 2 , 2-dimensional directed cube ( 2 \u00d7 2 ) , and 3-dimensional directed cube ( 2 \u00d7 2 \u00d7 2 ) . A cube may have points in it, and the directed interval 2 has two known points 0\u2082 : 2 and 1\u2082 : 2 . Tope layer adds logical constraints on the points in a cube, \"carving out\" a shape inside a space. There is a handful of ways to specify topes: TOP selects all points (provides no constraints) BOT selects no points (producing an empty shape) (\u03c6 \u2227 \u03c8) selects all points that satisfy both \u03c6 and \u03c8 (\u03c6 \u2228 \u03c8) selects all points that satisfy \u03c6 or \u03c8 (or both) (t \u2261 s) selects all points such that t is equal to s (t \u2264 s) selects all points such that t \u2264 s (only when both t and s are in 2 ) Mostly for technical reasons, we define shapes as mappings from cubes into the TOPE universe. For example, here is a shape that carves a (directed) triangle out of a (directed) square: #define \u0394\u00b2 : ( 2 \u00d7 2 ) \u2192 TOPE := \\ (t, s) \u2192 (s \u2264 t) Another example would be the horn shape that only takes two edges of a square: #define \u039b : ( 2 \u00d7 2 ) \u2192 TOPE := \\ (t, s) \u2192 (s \u2261 0\u2082 ) \u2228 (t \u2261 1\u2082 ) We could refine this definition by specifying that it is a subshape of \u0394\u00b2 : #define \u039b' : ( (t, s) : 2 \u00d7 2 | \u0394\u00b2 (t, s) ) \u2192 TOPE := \\ (t, s) \u2192 (s \u2261 0\u2082 ) \u2228 (t \u2261 1\u2082 ) Since shapes have the information about the cube in their types, Rzk provides an implicit coercion, allowing shorter definitions: #define \u039b'' : \u0394\u00b2 \u2192 TOPE := \\ (t, s) \u2192 (s \u2261 0\u2082 ) \u2228 (t \u2261 1\u2082 ) Note This more precise type expresses a restriction on the definition of \u039b'' , but, perhaps counterintuitively, not on the input points! With this type, Rzk additionally checks that (s \u2261 0) \u2228 (t \u2261 1 ) implies \u0394\u00b2 (t, s) for all t , s . However, we can still apply \u039b'' to all points in the cube ( 2 \u00d7 2 ) . Mapping from a shape into a type, effectively selects a concrete diagram in it. We can select a subdiagram, simply by restricting to a subshape: #define horn-restriction ( A : U) : (\u0394\u00b2 \u2192 A) \u2192 (\u039b \u2192 A) := \\ f t \u2192 f t To construct diagrams from parts, we can use recOR by specifying values for several shapes. Rzk will be checking that provided values agree (definitionally) on the intersections of these shapes. For example, given a triangle, we can construct a square: #define unfolding-square ( A : U) ( triangle : \u0394\u00b2 \u2192 A) : ( 2 \u00d7 2 ) \u2192 A := \\ (t, s) \u2192 recOR ( t \u2264 s \u21a6 triangle (s , t) , s \u2264 t \u21a6 triangle (t , s))","title":"Simplicial types with Rzk"},{"location":"1-demo.rzk/#extension-types-with-rzk","text":"Mapping from a shape into a type, we get a diagram. To fix some parts of the diagram, we can specify refinements \u2014 for each subshape we want to fix, we provide an explicit term of the proper type. For example, taking a diagram in A correspoding to the directed interval 2 and fixing the endpoints, we get the type of all arrows between two given points in A : #define hom ( A : U) ( x y : A) : U := ( t : 2 ) \u2192 A [ t \u2261 0\u2082 \u21a6 x , t \u2261 1\u2082 \u21a6 y ] We can show that the diagram 2 \u2192 A consists exactly of two elements and an arrow between them: #define \u03a3-arrow ( A : U) : U := \u03a3 ( x : A), \u03a3 ( y : A), hom A x y #define 2-to-\u03a3 ( A : U) : ( 2 \u2192 A) \u2192 \u03a3-arrow A := \\ d \u2192 (d 0\u2082 , (d 1\u2082 , d)) #define \u03a3-to-2 ( A : U) : (\u03a3-arrow A) \u2192 ( 2 \u2192 A) := \\ (x, (y, f)) \u2192 \\ t \u2192 recOR ( t \u2261 0\u2082 \u21a6 x , t \u2261 1\u2082 \u21a6 y , TOP \u21a6 f t )","title":"Extension types with Rzk"},{"location":"1-demo.rzk/#technical-cleanup","text":"The following definitions silence errors about unused variables. #define unused-y : X := y #define unused-z : X := z @import url(https://fonts.googleapis.com/css2?family=Noto+Serif&amp;display=swap); text, textPath { font-family: Noto Serif; font-size: 28px; dominant-baseline: middle; text-anchor: middle; } technically, in Rzk currently U contains also CUBE , TOPE universes, and itself! \u21a9 Emily Riehl & Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 \u21a9 Instead of builtin layers, Rzk uses CUBE and TOPE universes to separate them from the types. \u21a9","title":"Technical cleanup"},{"location":"2-exercises.rzk/","text":"Exercises \u00b6 This is a literate Rzk file: #lang rzk-1 Exercise 1 \u00b6 Show that modus-ponens is equal to a specialised identity . Solution to Exercise 1 Exercise 1 #define eq-modus-ponens-identity ( A B : U) : modus-ponens A B = identity (A \u2192 B) := refl Exercise 2 \u00b6 Define composition of (non-dependent) functions. That is, given f : A \u2192 B and g : B \u2192 C , provide a function of type A \u2192 C . Solution to Exercise 2 #define compose ( A B C : U) ( f : A \u2192 B) ( g : B \u2192 C) : A \u2192 C := \\ x \u2192 g (f x) Exercise 3 \u00b6 Show that the composition of 2-to-\u03a3 and \u03a3-to-2 either way is equal to identity . Solution to Exercise 3 #define eq-\u03a3-to-2-to-\u03a3 ( funext : FunExt) ( A : U) ( d : 2 \u2192 A) : compose ( 2 \u2192 A) (\u03a3-arrow A) ( 2 \u2192 A) (2-to-\u03a3 A) (\u03a3-to-2 A) = identity ( 2 \u2192 A) := funext ( 2 \u2192 A) ( 2 \u2192 A) (compose ( 2 \u2192 A) (\u03a3-arrow A) ( 2 \u2192 A) (2-to-\u03a3 A) (\u03a3-to-2 A)) (identity ( 2 \u2192 A)) ( \\ _ \u2192 refl ) #define eq-2-to-\u03a3-to-2 ( funext : FunExt) ( A : U) ( xyf : \u03a3-arrow A) : compose (\u03a3-arrow A) ( 2 \u2192 A) (\u03a3-arrow A) (\u03a3-to-2 A) (2-to-\u03a3 A) = identity (\u03a3-arrow A) := funext (\u03a3-arrow A) (\u03a3-arrow A) (compose (\u03a3-arrow A) ( 2 \u2192 A) (\u03a3-arrow A) (\u03a3-to-2 A) (2-to-\u03a3 A)) (identity (\u03a3-arrow A)) ( \\ _ \u2192 refl )","title":"Exercises"},{"location":"2-exercises.rzk/#exercises","text":"This is a literate Rzk file: #lang rzk-1","title":"Exercises"},{"location":"2-exercises.rzk/#exercise-1","text":"Show that modus-ponens is equal to a specialised identity . Solution to Exercise 1 Exercise 1 #define eq-modus-ponens-identity ( A B : U) : modus-ponens A B = identity (A \u2192 B) := refl","title":"Exercise 1"},{"location":"2-exercises.rzk/#exercise-2","text":"Define composition of (non-dependent) functions. That is, given f : A \u2192 B and g : B \u2192 C , provide a function of type A \u2192 C . Solution to Exercise 2 #define compose ( A B C : U) ( f : A \u2192 B) ( g : B \u2192 C) : A \u2192 C := \\ x \u2192 g (f x)","title":"Exercise 2"},{"location":"2-exercises.rzk/#exercise-3","text":"Show that the composition of 2-to-\u03a3 and \u03a3-to-2 either way is equal to identity . Solution to Exercise 3 #define eq-\u03a3-to-2-to-\u03a3 ( funext : FunExt) ( A : U) ( d : 2 \u2192 A) : compose ( 2 \u2192 A) (\u03a3-arrow A) ( 2 \u2192 A) (2-to-\u03a3 A) (\u03a3-to-2 A) = identity ( 2 \u2192 A) := funext ( 2 \u2192 A) ( 2 \u2192 A) (compose ( 2 \u2192 A) (\u03a3-arrow A) ( 2 \u2192 A) (2-to-\u03a3 A) (\u03a3-to-2 A)) (identity ( 2 \u2192 A)) ( \\ _ \u2192 refl ) #define eq-2-to-\u03a3-to-2 ( funext : FunExt) ( A : U) ( xyf : \u03a3-arrow A) : compose (\u03a3-arrow A) ( 2 \u2192 A) (\u03a3-arrow A) (\u03a3-to-2 A) (2-to-\u03a3 A) = identity (\u03a3-arrow A) := funext (\u03a3-arrow A) (\u03a3-arrow A) (compose (\u03a3-arrow A) ( 2 \u2192 A) (\u03a3-arrow A) (\u03a3-to-2 A) (2-to-\u03a3 A)) (identity (\u03a3-arrow A)) ( \\ _ \u2192 refl )","title":"Exercise 3"}]}